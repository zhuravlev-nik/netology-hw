# Домашнее задание к занятию "`Базы данных`" - `Журавлев Николай`

### Легенда

Заказчик передал вам [файл в формате Excel](https://github.com/netology-code/sdb-homeworks/blob/main/resources/hw-12-1.xlsx), в котором сформирован отчёт. 

На основе этого отчёта нужно выполнить следующие задания.

### Задание 1

Опишите не менее семи таблиц, из которых состоит база данных:

- какие данные хранятся в этих таблицах;
- какой тип данных у столбцов в этих таблицах, если данные хранятся в PostgreSQL.

Приведите решение к следующему виду:

Сотрудники (

- идентификатор, первичный ключ, serial,
- фамилия varchar(50),
- ...
- идентификатор структурного подразделения, внешний ключ, integer).

### Решение 1


```
employees (сотрудники) (
  id (integer, primary key, not null, autoincrement)
  first_name 
  last_name
  surname
  position_id (идентификатор должности) (integer, внешний ключ)
  division_id (идентификатор подразделения) (integer, внешний ключ)
)
```

```
salaries (оклады) (
  id (int, primary key, not null, autoincrement)
  employee_id (integer)
  summ (numeric(10,2))
  dateFrom 
)
```

Судя по данным из исходной таблицы, суммы окладов можем хранить в таблице пользователей (не заметил зависимости от должности), но если нужна история изменений оклада, то выносим в отдельную таблицу с привязкой к сотруднику и датой назначения. Если же привязка к должности должна быть, соответственно можем держать в таблице должностей, но в отдельной таблице будет вернее.

```
employee_projects (проекты + сотрудники) (
  id (int, primary key, not null, autoincrement)
  employee_id (int)
  project_id
)
```
Так как у сотрудника может быть несколько проектов одновременно, храним связи в отдельной таблице

```
positions (Должности) (
  id (int, primary key, not null, autoincrement)
  title
)
```
Должности не привязаны ни к чему (во всяком случае я в этих данных зависимости не заметил), так что просто храним их список

```
division_types (типы подразделений) (
  id (int, primary key, not null, autoincrement)
  name
)
```
Можно не выносить в отдельную таблицу, а исползьовать тип ENUM т.к. количество типов подразделений небольшое, но лучше держать отдельно для возможности простого расширения.

```
divisions Структурные подразделения (
  id (int, primary key, not null, autoincrement)
  name
  division_type_id
)
```

```
projects (Проекты) (
  id (int, primary key, not null, autoincrement)
  name
)
```

```
branches (Филиалы) (
  id
  title
  region_id
  city_id
  address
)
```
В таблице филиалов нет, только их адреса, но логически, они должны присутствовать, чтобы мы могли привязывать структурные подразделения к филиалам, а филиалы, в свою очередь, к адресам.

```
regions (Регионы) (
  id
  name
)
```

```
cities (Города) (
  id
  name
  region_id
)
```
Регионы и города вынесены в отдельные таблицы чтобы избежать дублирования.

---

### Задание 2*

Перечислите, какие, на ваш взгляд, в этой денормализованной таблице встречаются функциональные зависимости и какие правила вывода нужно применить, чтобы нормализовать данные.

### Решение 2*
Не уверен, что верно понял вопрос, соответственно, не совсем уверен, что ответ этому вопросу соответствует.
 
* ФИО сотрудника - оклад
* ФИО сотрудника - должность
* ФИО сотрудника - дата найма
* ФИО сотрудника - проект
* ФИО сотрудника - структурное подразделение
* Структурное подразделение - тип структурного подразделения
* Структурное подразделение - филиал - адрес филиала (но в данном случае нет сущности "филиал", в идеале, как мне кажется, структурные подразделения нужно привязывать к филиалам, и к филиалам же привязывать их адреса)

Для нормализации:
* привести к первой нормальной форме, устранив многозначные атрибуты (в нешем случае проекты)
* привести ко второй нормальной форме, вынеся зависимости в отдельные таблицы и установим им первичные ключи
* привести к третьей нормальной форме, устранив транзитивные зависимости, т.е. зависимость атрибутов от атрибутов через другие атрибуты.

Это поможет уменьшить избыточность (убрать дублирование) и улучшить структуру данных.